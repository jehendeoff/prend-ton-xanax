<!DOCTYPE html>
<html lang="en-en">

<head>
	<meta charset="utf-8">
	<script crossorigin="anonymous" referrerpolicy="no-referrer"
		src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.4.0/socket.io.js?version=4.4.0"></script>
</head>

<body>
	<h1 id="loading">Loading, please wait.</h1>

</body>
<style>
	* {
		font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif
	}
	table{
		border-collapse: collapse;
	}
	th{
		width: max-content;
		padding: 0px 3px;
	}
	th:nth-child(5){
		background-color: #fbb;
		cursor: pointer;
	}
	tr:nth-child(odd){
		background-color: #bbb;
	}
	tr:nth-child(odd) > th:nth-child(5){
		background-color: #f99;
	}
	tr:nth-child(1){
		background-color: #444 ;
		color: #fff;
	}
	tr:nth-child(1) > th:nth-child(5){
		background-color: #444 ;
	}

	.wrapper{
		display:grid;
		grid-gap: 10px;
		grid-template-columns: repeat(auto-fit, 200px);
	}
	.wrapper a {
		text-align: center;
		box-shadow: rgba(0, 0, 0, 0.2) 0px 8px 24px;
		border-radius: 5px;
		border-width: 2px;
		border-style: solid;
		border-color: rgba(0,0,0,0);
		padding: 10px 5px;
		font-size: xx-large;
		cursor: pointer;
	}
	.wrapper a.downloaded{
		cursor:not-allowed;
		background-color: #bbb;
	}
	.errored{
		color:#f22;
	}
	.finished{
		color:#2f2;
	}
	.waiting{
		color:#888;
	}
	.working{
		animation-name: working;
		animation-duration: 1s;
		animation-timing-function: linear;
		animation-iteration-count: infinite;
	}
	@keyframes working {
		0% { color: #888; }
		50% { color: #000; }
		100% { color: #888; }
	}
	input[TYPE="text"] {
		width: 400px;
	}
</style>
<script>
	if(typeof io === "undefined") {
		document.getElementsByTagName("h1")[0].innerText="Socket.io wasn't able to load.";
		throw new Error("Socket.io wasn't able to load");
	}

	// let lobby =io("/lobby", {
	// 	rememberUpgrade : true,
	// });
	let download =io("/download", {
		rememberUpgrade : true,
	});
	const table = document.createElement("table");
	document.body.appendChild(table);
	const tbody = document.createElement("tbody");
	table.append(tbody);
	const tr = document.createElement("tr");
	tbody.append(tr);
	function thAppend(text){
		const th = document.createElement("th");
		th.innerText = text;
		tr.append(th);
	}
	thAppend("Anime");
	thAppend("File name");
	thAppend("Speed");
	thAppend("%");
	thAppend("Annuler");
	download.on("status", list => {
		//console.log(list);
		[...tbody.children].filter((e,i)=> i>= 1).map(e => e.remove());
		function t (t){
			if (document.getElementById("tracer").children.length !== 0) [...document.getElementById("tracer").children[1].children]
			.forEach(e => {
				e.classList.remove(t)
			})


			const obj = list[t];
			let arr = Object.entries(obj);
			arr = arr.sort((c,d) =>{
				const a = c[1];
				const b = d[1];

				let i = 0;
				if (a.info > b.info) i+= 1
				if (a.info < b.info) i+= -1


				if (a.filename > b.filename) i+= 0.5
				if (a.filename < b.filename) i+= -0.5
				return i;
			})
			arr = arr.filter (e=> e[0] !== "size");
			arr.forEach(obj => {
				const downloadState = obj[1];
				const tr = document.createElement("tr");
				tbody.appendChild(tr);
				function thAppend(text){
					const th = document.createElement("th");
					th.innerText = text;
					th.className = t;
					tr.appendChild(th);
					return th;
				}
				thAppend(downloadState["info"] ? downloadState["info"]["anime"] ?? "" : "")
				thAppend(downloadState["filename"] ?? "");
				thAppend(downloadState["speed"] ?? "");
				const percent = (downloadState["percent"] ?? "").slice(0,5)
				thAppend(percent !== "" ? percent + "%" : "");
				const stop = thAppend("🗑️");
				if (downloadState["stopping"] !== true){
					stop.onclick = ()=> {
						download.emit("stop", obj[0].toString());
						tr.style.setProperty("color", "red");
						stop.innerText = "♻️";
						stop.onclick = ()=> {};
					}
				}else{
					stop.innerText = "♻️";
					stop.onclick = ()=> {};
				}

				if (document.getElementById("tracer").children.length !== 0){

					if (downloadState["info"] && downloadState["info"]["anime"] === document.getElementById("tracer").children[0].innerText){
						[...document.getElementById("tracer").children[1].children]
						.filter(e => e.hasAttribute("ep") && e.getAttribute("ep") === downloadState["info"]["ep"])
						.forEach(e => {
							e.classList.add(t)
						})

					}
				}



			})
			// for (const key in list[t]) {
			// 	if (key !== "size"){
			// 		// const downloadState = list[t][key];
			// 		// const tr = document.createElement("tr");
			// 		// tbody.appendChild(tr);
			// 		// function thAppend(text){
			// 		// 	const th = document.createElement("th");
			// 		// 	th.innerText = text;
			// 		// 	tr.appendChild(th);
			// 		// }
			// 		// thAppend(downloadState["filename"] ?? "");
			// 		// thAppend(downloadState["speed"] ?? "");
			// 		// const percent = (downloadState["percent"] ?? "").slice(0,5)
			// 		// thAppend(percent !== "" ? percent + "%" : "");
			// 	};
			// }
		}
		t("errored")
		t("working");
		t("waiting");
		t("finished")


	});


	const br = document.createElement("br");
	document.body.appendChild(br);


	const inputTracer = document.createElement("input");
	inputTracer.setAttribute("type", "text")
	inputTracer.value = "https://animedao.to/anime/le-portrait-de-petit-cossette/";
	document.body.appendChild(inputTracer);

	const confirmTracer = document.createElement("input");
	confirmTracer.setAttribute("type", "submit")

	download.on("connect", ()=> {
		confirmTracer.disabled = false;
		inputTracer.disabled = false;
	})

	confirmTracer.onclick = ()=> {
		confirmTracer.disabled = true;
		inputTracer.disabled = true;
		download.emit("trace", {
			url: inputTracer.value,
			module: inputTracer.value.match(/https?:\/\/([^.]*)/)[1]
		})
	}
	document.body.appendChild(confirmTracer);

	const br1 = document.createElement("br");
	document.body.appendChild(br1);

	const div = document.createElement("div");
	div.setAttribute("id", "tracer")
	document.body.appendChild(div);
	download.on("tracer", m => {
		confirmTracer.disabled = false;
		inputTracer.disabled = false;
		m = JSON.parse(m),
		[...div.children].forEach(e => e.remove());

		const h1 = document.createElement("h1");
		h1.innerText = m.name;
		div.append(h1);
		const div2 = document.createElement("div");
		div2.className = "wrapper";
		div.append(div2);

		for (const key in m["ep"]) {
			const a = document.createElement("a");
			const PreText = key.toString().includes("-") ? "S" : "Episode";

			a.innerText = `${PreText} ${key.toString().includes("-") ? key.toString().replace("-", "EP") : key.toString()}`;
			//NOTE, this can be better (such as a separator for seasons)
			const ep = key.match(/[0-9., -]*/g)[0];
			a.setAttribute("ep", ep)
			if (m["ep"][key]["downloaded"] !==true){
				a.onclick = () => {
					download.emit("add", {url:m["ep"][key]["url"], module: m.module, filename: ep, path: m["path"], info: {anime: m.name, ep: ep}})
				}
			}else{
				a.className="downloaded"
			}
			div2.append(a);
		}
	})
	download.on("stop", console.log)

	document.getElementById("loading").innerText = "Downloader"


</script>
</html>